{"meta":{"title":"王涛的博客","subtitle":"wangtao","description":"wangtao,王涛的博客","author":"wangtao","url":"https://www.itnwork.com"},"pages":[{"title":"","date":"2019-03-13T09:18:49.453Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"baidu_verify_FD6111xvq4.html","permalink":"https://www.itnwork.com/baidu_verify_FD6111xvq4.html","excerpt":"","text":"FD6111xvq4"},{"title":"","date":"2019-03-13T09:18:49.453Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"google9e3369a38891851f.html","permalink":"https://www.itnwork.com/google9e3369a38891851f.html","excerpt":"","text":"google-site-verification: google9e3369a38891851f.html"},{"title":"","date":"2019-03-13T09:18:49.453Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"gulpfile.js","permalink":"https://www.itnwork.com/gulpfile.js","excerpt":"","text":"(function() { 'use strict'; var gulp = require('gulp'), less = require('gulp-less'), rename = require('gulp-rename'), minifycss = require('gulp-minify-css'), autoprefixer = require('gulp-autoprefixer'), uglify = require('gulp-uglify'), jshint = require('gulp-jshint'), stylish = require('jshint-stylish'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), htmlclean = require('gulp-htmlclean'), htmlmin = require('gulp-htmlmin'), rev = require('gulp-rev-append'), // sequence = require('gulp-sequence'), path = require('path'), paths = { root: './', source: './themes/hexo-theme-snippet/source/' //主题下原文件 } /*==================================================== 开发主题 ====================================================*/ // CSS预处理 gulp.task('less-task', function() { return gulp.src(paths.source + 'css/less/_style.less') .pipe(plumber({ errorHandler: notify.onError('Error: ') })) .pipe(less()) .pipe(rename({basename: \"style\"})) .pipe(gulp.dest(paths.source + 'css')) .pipe(notify({message: 'less compile complete'})); }); // 校验JS语法和风格 gulp.task('js-task', function() { return gulp.src(paths.source + 'js/*.js') .pipe(jshint()) .pipe(jshint.reporter(stylish)) .pipe(gulp.dest(paths.source + 'js/')) .pipe(notify({message: 'js compile complete'})); }); // 监听任务-主题开发模式 gulp.task('dev', function() { gulp.watch(paths.source + 'css/less/*.less', function() { return gulp.src(paths.source + 'css/less/_style.less') .pipe(plumber({ errorHandler: notify.onError('Error: ') })) .pipe(less()) .pipe(rename({basename: \"style\"})) .pipe(gulp.dest(paths.source + 'css')) .pipe(notify({message: 'less compile complete'})); }); gulp.watch(paths.source + 'js/*.js', function() { return gulp.src(paths.source + 'js/*.js') .pipe(jshint()) .pipe(jshint.reporter(stylish)) .pipe(gulp.dest(paths.source + 'js/')) .pipe(notify({message: 'js compile complete'})); }); }); /*==================================================== 部署前代码处理 ====================================================*/ // 压缩处理 css gulp.task('minify-css', function() { return gulp.src('./public/**/*.css') .pipe(autoprefixer({ browsers: ['last 10 versions', 'Firefox >= 20', 'Opera >= 36', 'ie >= 9', 'Android >= 4.0', ], cascade: true, //是否美化格式 remove: false //是否删除不必要的前缀 })) .pipe(minifycss()) .pipe(gulp.dest('./public')) .pipe(notify({message: 'css minify complete'})); }); // 压缩处理 js gulp.task('minify-js', function() { return gulp.src('./public/js/*.js') .pipe(uglify()) .pipe(gulp.dest('./public/js')) .pipe(notify({message: 'js minify complete'})); }); // 压缩处理 html gulp.task('minify-html', function() { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true })) .pipe(gulp.dest('./public')); }); // 添加版本号 gulp.task('rev', function() { return gulp.src('./public/**/*.html') .pipe(rev()) .pipe(gulp.dest('./public')); }); // 同步执行task //gulp.task('deploy',sequence(['minify-css','minify-js'],'rev','minify-html')); gulp.task('deploy',gulp.parallel( gulp.series( 'minify-css', 'minify-js' ), 'rev', 'minify-html' ) ); // 部署前代码处理 //gulp.task('default',['deploy'],function(e){ // console.log(\"[complete] please execute： hexo d\"); //}) gulp.task('default',gulp.series( 'deploy', function(done){ console.log(\"[complete] please execute： hexo d\"); done(); } )) })();"},{"title":"categories","date":"2019-03-06T11:12:32.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"categories/index.html","permalink":"https://www.itnwork.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-06T11:18:46.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"tags/index.html","permalink":"https://www.itnwork.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo+github最新最完整的建站过程","slug":"hexo+github最新最完整的建站过程","date":"2019-03-12T00:08:08.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"archives/85cb8b79.html","link":"","permalink":"https://www.itnwork.com/archives/85cb8b79.html","excerpt":"","text":"一、注册github账号github注册地址 另外github支持当前版本的Chrome、Firefox、Safari和Microsoft Edge。 填写注册信息： 其中Username为你github账户的名字，取完之后就改不了了。 Email address为你的邮箱地址。 Password设置你的密码。 然后点击验证，Create an account. 继续Continue,这一步你可以选择跳过，也可以根据你的情况选择一下submit。 然后确认下你的邮箱； 确认完后登录到你的github页面。 点击Your repositories 二、创建github pages点击New，新建一个仓库。 Repository name必须是这种格式 xxxx.github.io。 xxxx为你刚刚注册github账号的名字。 点击Create repository后，跳转到下面这个页面。 点击Settings 。 至此你的github静态页面存储库就创建成功了。不防点下你的新建的网址，https://your_github_repostoriesName.github.io 试试看。 三、本地连接GitHub 生成SSH添加到GitHub现在我们需要在本地配置下git，让它能连接到Github仓库。 git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot;例如我的： git config --global user.name &quot;doerteacher&quot;，注册github的账号名称。 git config --global user.email &quot;xxxxxxx@qq.com&quot;,注册github的邮箱。 然后创建ssh，一路回车。 ssh-keygen -t rsa -C “youremail” 默认生成ssh key在C:\\Users\\电脑用户名\\ .ssh文件夹下。 然后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你id_rsa.pub里面的信息复制进去。 点击Setting，进入SSH and GPG keys页面。点击SSH and GPG keys，然后点击New SSH key。Title随便起个名，比如blog。把id_rsa.pub里面的信息复制到Key里面。 然后输入 ssh -T git@github.com 检测下是否配置成功。 然后会得到如下信息，证明你配置成功了。Hi DoerTeacher! You’ve successfully authenticated, but GitHub does not provide shell access. 四、Hexo创建 Hexo创建前环境准备 Git安装下载Git 基于你电脑的系统自行选择下载哪个版本。 如果不会Git怎么安装的话，网上自己搜索下Git具体安装步骤。 nodejs安装nodejs下载 基于你电脑的系统自行选择下载哪个版本。 如果不会nodejs怎么安装的话，网上自己搜索下Git具体安装步骤。 安装完后，打开cmd工具,输入node -v 检测下安装的版本。 至此nodejs安装完毕。 接下来就可以真正安装hexo了。 Hexo安装首先在自己电脑的D盘，建个存储Hexo文件的文件夹。 例如我在D盘user文件夹下新建了个Hexo文件夹： ##然后打开自己电脑的Git Bash 然后cd到Hexo文件夹下，输入 npm install -g hexo-cli，安装hexo。 输入hexo -v，看下hexo当前版本 然后初始化hexo hexo init blog 然后cd到刚刚初始化的blog文件夹下。cd blog/ 这时你会发现新建了这么几个文件。 然后安装npm 依赖项。 npm install 然后hexo g，生成静态文件。 然后 ls,你会发现多了public文件夹，这就是生成的静态文件页面。 然后 hexo server 启动服务器。 访问网址为： http://localhost:4000/ 然后就进入了hello world的页面。 这时就代表了你的hexo安装完成了。 前面我们已经在github上建了存储静态页面的仓库并配置了本地连接Github。 然后我们就可以把hexo生成的页面部署到github上了。 五、将hexo部署到GitHub打开站点配置文件 _config.yml，在刚才生成的blog目录下。在_config.yml最下面，找到deploy： 修改为 deploy: type: git repository: git@github.com:DoerTeacher/doerteacher.github.io.git branch: master DoerTeacher就是我的GitHub账户名，你得改成你自己的。 repository地址也可以到自己GitHub账户的仓库下复制。 然后安装 部署到github插件的依赖npm install hexo-deployer-git --save这个时候就可以开始真正地将hexo部署到github上了。hexo deploy然后就可以在http://doerteacher.github.io ，访问你自己的博客了。 其中doerteacher.github.io为你之前创建的Repository Name。 然后你就可以看到这样的页面了。 至于hexo的使用、添加评论功能、绑定自定义域名，以及自动化集成部署我将会在下一篇博文中完整地整理出来。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.itnwork.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://www.itnwork.com/tags/github/"},{"name":"建站","slug":"建站","permalink":"https://www.itnwork.com/tags/建站/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}]},{"title":"万网DNS与其他云解析系统比较","slug":"万网DNS与其他云解析系统比较","date":"2019-03-08T11:18:57.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"archives/f21a6563.html","link":"","permalink":"https://www.itnwork.com/archives/f21a6563.html","excerpt":"","text":"注册域名以后，您只拥有了这个域名的使用权，但无法通过域名直接访问您的网站，或作为电子邮箱后缀进行邮件收发。原因在于，域名只是为了方便记忆而专门建立的一套地址转换系统，要访问一台互联网上的服务器，必须通过 IP 地址来实现。而域名解析就是将域名指向 IP 地址的过程。“域名解析”是使用域名的必备环节。 您需要选择优秀的服务商，确保您的域名在解析过程中拥有稳定、快速、安全的服务保障，从而获得最佳的服务器访问体验。 一、什么是万网云解析？万网云解析是万网 DNS 系统面向全网域名升级开放的免费智能域名解析服务，提供稳定、安全、极速的域名解析能力，支持非万网域名海外 IP 解析，且全部功能免费使用。 12345671、稳定，99.99% 服务可用率。阿里强大的网络基础设施布局，独享多线 BGP 的多机房集群自动宕机迁移，系统性能监测实时报警，让每一次访问使命必达！2、安全，拥有淘宝级防护能力。阿里自主研发的超百 G 流量清洗中心，可对攻击行为迅速做出判断跟踪，并按照预案进行处理，确保域名解析服务稳定可靠！3、极速，解析实时生效。域名解析记录实时更新，自动判断访问用户来自联通、电信、移动、教育易用，强大功能轻松体验。直观简捷的操作面板与友好的功能提示，人性化解析设置操作零成本上手，随时启动云解析的强大功能！4、平滑，解析切换无感知。域名添加成功后，即可预设解析记录，一旦 DNS 更换生效，解析服务平滑切换，访问体验不中断！ 二、万网域名解析的优势来自 DailyChange 的权威第三方数据统计显示，万网云解析是国内域名解析市场第一的服务提供商，拥有最多的域名解析保有量。基于万网 19 年的稳定解析服务保障，以及阿里的技术能力与网络基础设施布局，超过 300 万域名用户正在使用万网云解析。 万网云解析提供了 99.99% 的服务可用率保证，拥有淘宝级的安全防护能力，以及实时解析生效，确保稳定、安全、极速的解析能力；支持高质量的电信、联通、移动、教育网和海外的多线智能解析，获得最流畅的访问体验；全部功能均免费面向所有用户提供。 新版万网云解析升级发布，开放支持非万网域名以及海外 IP 解析。 域名注册商提供的免费服务Godaddy：不在Godaddy注册域名，也可以使用Godaddy的域名解析服务，使用方法很简单，登录Godaddy网站后，点击“Add Off-site DNS”即可添加用户的域名，之后将用户域名的DNS设置为Godaddy指定的地址，域名DNS生效后，即可点击添加的域名进行DNS解析设置。 NameCheap：知名的域名注册商NameCheap也和Godaddy一样，提供免费DNS域名解析，点击“FreeDNS”后，即可添加用户域名，用户可以通过修改DNS或域名邮件来验证自己的域名，NameCheap的解析服务支持的功能有：网址转发（可隐藏原URL、支持301重定向）、邮件转发、A记录、CNAME别名记录、MX邮件记录、TXT文本记录、NS记录、AAAA记录（IPV6）、动态域名解析等等。 国内免费域名解析服务DNSPod：DNSPod是国内运营较久的免费DNS解析服务，除了免费服务外，还提供多项收费服务。DNSPod的功能较多，支持电信、网通、教育网双线或者三线智能DNS解析，在中国国内解析速度较快，但对于国外的Google爬虫来说经常出现无法访问的情况。 DNS.La：也是类似DNSPod的免费DNS解析服务，可以为同时有电信、联通、教育网服务器的网站提供免费智能DNS的解析。 EDNS：易名中国提供的免费域名解析服务，非易名中国用户也可使用。 国外免费域名解析服务ZoneEdit：美国著名的老牌免费域名DNS解析服务，成立于1999年。免费帐户最多可添加5个域名。解析类型：A记录、AAAA记录、 TXT文本记录、LOC记录、PTR记录、CNAME别名记录、MX邮件记录、网址转发、邮件转发等。界面超级简洁，速度快，稳定。 HE.NET：是美国老牌IDC，成立于1994年，在技术领域比较强，尤其是IPV6应用。这个免费DNS解析服务最多可以添加50个域名，可以设置A记录、AAAA记录、CNAME别名记录、MX邮件记录、NS记录、TXT记录、SRV记录。 FreeDNS：一家美国免费域名DNS解析服务网站，界面简洁，注册简单，支持添加任何后缀的域名，支持Google Apps服务。免费域名DNS解析服务有三种模式：简单模式可直接设置IP指向、转发模式可设置301永久重定向和302临时重定向、高级模式可设置A记录、AAAA记录、CNAME记录、MX记录、PTR记录、TXT记录。 afraid：美国一家免费域名解析服务，运营了相当长的时间了，值得提醒的是按照官方规定六个月账号必须有一次登录，否则账号会被锁定 。 CDN服务自带域名解析CloudFlare：虽然它的主营业务是CDN（Anycast），但丝毫不影响它作为免费DNS的声誉，况且这个免费DNS是真的全球分布（12个节点），且使用了CDN技术。 百度加速乐：加速乐也主要是CDN业务，顺带提供DNS域名解析，提供抗CC攻击、免费DNS解析、免费分省解析、防黑客攻击、黑链暗链防护、页面篡改防护服务。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://www.itnwork.com/tags/DNS/"},{"name":"云解析","slug":"云解析","permalink":"https://www.itnwork.com/tags/云解析/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}]},{"title":"二月二龙抬头","slug":"二月二龙抬头","date":"2019-03-08T09:12:12.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"archives/c40fbf14.html","link":"","permalink":"https://www.itnwork.com/archives/c40fbf14.html","excerpt":"","text":"18年已经过去两个月了，我翻开笔记本，看着我一年的晨间日记，还有那几个小目标，陷入了沉思。 很久之前都想对去年做个总结，对今年做下展望，由于惰性，一直拖到现在才来开始做。 对于19年我的愿望是什么，我一直在问我自己。 最后通过对过去不断地总结我发现，我19年的最大愿望，就是继续完成18年未完成的愿望。 回顾2018，做的对的几件大事： 一直把学习放在第一位； 对于错误的方向果断的放下； 自修能量改变自己； 做的错的几件事情： 低谷的时候不能沉迷，没能站高一线，看待全局； 我过去成功的经验，反而成了我上半年道路上的阻碍； 当我在抱怨的时候，有大巴人在偷偷赚大钱； 对待2019，将要做的三件事： 1、自修能量改变自己 2、珍惜身边关心自己的人 3、把抖商做起来。 对于自己能够不断地自修能量改变自己，我最应该感谢李枝慧，一个见证了我的起起落落，一直陪伴在我左右的人，没有她不会有我现在的改变。 人只有在你没有势能的时候才能看清人的本质，所以，举杯，庆祝人生的低谷，让你可以认清身边很多风景。 做事是术，做人是道，道是根本！ 学到影响最深刻的几句话是： 正念厚德，利众利他 格局决定高度，心态决定状态，初心决定未来 做好自己，做个好人，用真心换真心 脚踏实地，不抄近道 言而有信，有诺必践 有一句金句对我感触很大：我们每年要把自己的能力提升30%，收入至少也要提升30%，如果你能力提升了，收入没有提升，那你需要换圈子！ 经营自己的圈子是多么重要，这一点我最佩服蝉老大，做人他第一，没有之一。 亿万身家还能做好一个小弟，真的太难了。 我和他距离还有很多段。 最近在家里闭关，给2019年布局： 空杯心态不断学习，体系不断完善； 自修——八风吹不动，端坐紫金莲； 善待生命中出现的每一个人，因为三世修炼才换今生一次回眸； 帮助媳妇搭建一个工大流量池； 带父母出去旅行一次； 多认识10个朋友； 保持锻炼；","categories":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}],"tags":[{"name":"规划","slug":"规划","permalink":"https://www.itnwork.com/tags/规划/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://www.itnwork.com/categories/工具/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2015-10-21T02:34:12.000Z","updated":"2019-03-13T09:18:49.453Z","comments":true,"path":"archives/e598dc64.html","link":"","permalink":"https://www.itnwork.com/archives/e598dc64.html","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","text":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 min-width、max-width、font-size 和 line-height 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) == $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://www.itnwork.com/tags/css/"}],"keywords":[]}]}